CREATE TABLE syncup.projects (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name         VARCHAR NOT NULL,
  owner_id     BIGINT NOT NULL REFERENCES syncup.users(id), -- who created/owns the project
  description  TEXT,
  delete_ind   BOOLEAN,
  created_by   BIGINT NOT NULL REFERENCES syncup.users(id),
  updated_by   BIGINT NOT NULL REFERENCES syncup.users(id),
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TRIGGER project_updated_at
  BEFORE UPDATE ON syncup.projects
  FOR EACH ROW
  EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER project_update_log_trg
  AFTER UPDATE ON syncup.projects
  FOR EACH ROW 
  EXECUTE FUNCTION log_update();


CREATE TABLE syncup.project_members (
  project_id BIGINT NOT NULL,
  user_id    BIGINT NOT NULL,
  added_by   BIGINT NOT NULL,
  added_at   TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- composite PK ensures one row per (project, user)
  CONSTRAINT project_members_pkey PRIMARY KEY (project_id, user_id),

  -- cascades make sense for membership rows tied to a project/user
  CONSTRAINT project_members_project_fk
    FOREIGN KEY (project_id) REFERENCES syncup.projects(id) ON DELETE CASCADE,
  CONSTRAINT project_members_user_fk
    FOREIGN KEY (user_id)    REFERENCES syncup.users(id)    ON DELETE CASCADE,

  -- usually you donâ€™t want to delete memberships just because the actor user is deleted
  CONSTRAINT project_members_added_by_fk
    FOREIGN KEY (added_by)   REFERENCES syncup.users(id)    ON DELETE RESTRICT
);

CREATE INDEX IF NOT EXISTS idx_project_members_user_id  ON syncup.project_members (user_id);
CREATE INDEX IF NOT EXISTS idx_project_members_project_id ON syncup.project_members (project_id);